// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod open_mahjong {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MENTSU_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MENTSU_TYPE: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MENTSU_TYPE: [MentsuType; 5] = [
  MentsuType::TYPE_SHUNTSU,
  MentsuType::TYPE_KOUTSU,
  MentsuType::TYPE_MINKAN,
  MentsuType::TYPE_ANKAN,
  MentsuType::TYPE_ATAMA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MentsuType(pub u8);
#[allow(non_upper_case_globals)]
impl MentsuType {
  pub const TYPE_SHUNTSU: Self = Self(0);
  pub const TYPE_KOUTSU: Self = Self(1);
  pub const TYPE_MINKAN: Self = Self(2);
  pub const TYPE_ANKAN: Self = Self(3);
  pub const TYPE_ATAMA: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TYPE_SHUNTSU,
    Self::TYPE_KOUTSU,
    Self::TYPE_MINKAN,
    Self::TYPE_ANKAN,
    Self::TYPE_ATAMA,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TYPE_SHUNTSU => Some("TYPE_SHUNTSU"),
      Self::TYPE_KOUTSU => Some("TYPE_KOUTSU"),
      Self::TYPE_MINKAN => Some("TYPE_MINKAN"),
      Self::TYPE_ANKAN => Some("TYPE_ANKAN"),
      Self::TYPE_ATAMA => Some("TYPE_ATAMA"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MentsuType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MentsuType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MentsuType {
    type Output = MentsuType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MentsuType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MentsuType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MentsuType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MENTSU_FLAG: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MENTSU_FLAG: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MENTSU_FLAG: [MentsuFlag; 4] = [
  MentsuFlag::FLAG_NONE,
  MentsuFlag::FLAG_KAMICHA,
  MentsuFlag::FLAG_TOIMEN,
  MentsuFlag::FLAG_SIMOCHA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MentsuFlag(pub u8);
#[allow(non_upper_case_globals)]
impl MentsuFlag {
  pub const FLAG_NONE: Self = Self(0);
  pub const FLAG_KAMICHA: Self = Self(1);
  pub const FLAG_TOIMEN: Self = Self(2);
  pub const FLAG_SIMOCHA: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FLAG_NONE,
    Self::FLAG_KAMICHA,
    Self::FLAG_TOIMEN,
    Self::FLAG_SIMOCHA,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FLAG_NONE => Some("FLAG_NONE"),
      Self::FLAG_KAMICHA => Some("FLAG_KAMICHA"),
      Self::FLAG_TOIMEN => Some("FLAG_TOIMEN"),
      Self::FLAG_SIMOCHA => Some("FLAG_SIMOCHA"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MentsuFlag {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MentsuFlag {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MentsuFlag {
    type Output = MentsuFlag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MentsuFlag {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MentsuFlag {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MentsuFlag {}
pub enum PaiOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Pai<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Pai<'a> {
  type Inner = Pai<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Pai<'a> {
  pub const VT_PAI_NUM: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_IS_TSUMOGIRI: flatbuffers::VOffsetT = 8;
  pub const VT_IS_RIICHI: flatbuffers::VOffsetT = 10;
  pub const VT_IS_NAKARE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Pai { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PaiArgs
  ) -> flatbuffers::WIPOffset<Pai<'bldr>> {
    let mut builder = PaiBuilder::new(_fbb);
    builder.add_is_nakare(args.is_nakare);
    builder.add_is_riichi(args.is_riichi);
    builder.add_is_tsumogiri(args.is_tsumogiri);
    builder.add_id(args.id);
    builder.add_pai_num(args.pai_num);
    builder.finish()
  }

  pub fn unpack(&self) -> PaiT {
    let pai_num = self.pai_num();
    let id = self.id();
    let is_tsumogiri = self.is_tsumogiri();
    let is_riichi = self.is_riichi();
    let is_nakare = self.is_nakare();
    PaiT {
      pai_num,
      id,
      is_tsumogiri,
      is_riichi,
      is_nakare,
    }
  }

  #[inline]
  pub fn pai_num(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Pai::VT_PAI_NUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Pai::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn is_tsumogiri(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Pai::VT_IS_TSUMOGIRI, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_riichi(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Pai::VT_IS_RIICHI, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_nakare(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Pai::VT_IS_NAKARE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Pai<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("pai_num", Self::VT_PAI_NUM, false)?
     .visit_field::<u8>("id", Self::VT_ID, false)?
     .visit_field::<bool>("is_tsumogiri", Self::VT_IS_TSUMOGIRI, false)?
     .visit_field::<bool>("is_riichi", Self::VT_IS_RIICHI, false)?
     .visit_field::<bool>("is_nakare", Self::VT_IS_NAKARE, false)?
     .finish();
    Ok(())
  }
}
pub struct PaiArgs {
    pub pai_num: u8,
    pub id: u8,
    pub is_tsumogiri: bool,
    pub is_riichi: bool,
    pub is_nakare: bool,
}
impl<'a> Default for PaiArgs {
  #[inline]
  fn default() -> Self {
    PaiArgs {
      pai_num: 0,
      id: 0,
      is_tsumogiri: false,
      is_riichi: false,
      is_nakare: false,
    }
  }
}

pub struct PaiBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PaiBuilder<'a, 'b> {
  #[inline]
  pub fn add_pai_num(&mut self, pai_num: u8) {
    self.fbb_.push_slot::<u8>(Pai::VT_PAI_NUM, pai_num, 0);
  }
  #[inline]
  pub fn add_id(&mut self, id: u8) {
    self.fbb_.push_slot::<u8>(Pai::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_is_tsumogiri(&mut self, is_tsumogiri: bool) {
    self.fbb_.push_slot::<bool>(Pai::VT_IS_TSUMOGIRI, is_tsumogiri, false);
  }
  #[inline]
  pub fn add_is_riichi(&mut self, is_riichi: bool) {
    self.fbb_.push_slot::<bool>(Pai::VT_IS_RIICHI, is_riichi, false);
  }
  #[inline]
  pub fn add_is_nakare(&mut self, is_nakare: bool) {
    self.fbb_.push_slot::<bool>(Pai::VT_IS_NAKARE, is_nakare, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PaiBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PaiBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Pai<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Pai<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Pai");
      ds.field("pai_num", &self.pai_num());
      ds.field("id", &self.id());
      ds.field("is_tsumogiri", &self.is_tsumogiri());
      ds.field("is_riichi", &self.is_riichi());
      ds.field("is_nakare", &self.is_nakare());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PaiT {
  pub pai_num: u8,
  pub id: u8,
  pub is_tsumogiri: bool,
  pub is_riichi: bool,
  pub is_nakare: bool,
}
impl Default for PaiT {
  fn default() -> Self {
    Self {
      pai_num: 0,
      id: 0,
      is_tsumogiri: false,
      is_riichi: false,
      is_nakare: false,
    }
  }
}
impl PaiT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Pai<'b>> {
    let pai_num = self.pai_num;
    let id = self.id;
    let is_tsumogiri = self.is_tsumogiri;
    let is_riichi = self.is_riichi;
    let is_nakare = self.is_nakare;
    Pai::create(_fbb, &PaiArgs{
      pai_num,
      id,
      is_tsumogiri,
      is_riichi,
      is_nakare,
    })
  }
}
pub enum MentsuPaiOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MentsuPai<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MentsuPai<'a> {
  type Inner = MentsuPai<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MentsuPai<'a> {
  pub const VT_PAI_NUM: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_FLAG: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MentsuPai { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MentsuPaiArgs
  ) -> flatbuffers::WIPOffset<MentsuPai<'bldr>> {
    let mut builder = MentsuPaiBuilder::new(_fbb);
    builder.add_flag(args.flag);
    builder.add_id(args.id);
    builder.add_pai_num(args.pai_num);
    builder.finish()
  }

  pub fn unpack(&self) -> MentsuPaiT {
    let pai_num = self.pai_num();
    let id = self.id();
    let flag = self.flag();
    MentsuPaiT {
      pai_num,
      id,
      flag,
    }
  }

  #[inline]
  pub fn pai_num(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(MentsuPai::VT_PAI_NUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(MentsuPai::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flag(&self) -> MentsuFlag {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MentsuFlag>(MentsuPai::VT_FLAG, Some(MentsuFlag::FLAG_NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MentsuPai<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("pai_num", Self::VT_PAI_NUM, false)?
     .visit_field::<u8>("id", Self::VT_ID, false)?
     .visit_field::<MentsuFlag>("flag", Self::VT_FLAG, false)?
     .finish();
    Ok(())
  }
}
pub struct MentsuPaiArgs {
    pub pai_num: u8,
    pub id: u8,
    pub flag: MentsuFlag,
}
impl<'a> Default for MentsuPaiArgs {
  #[inline]
  fn default() -> Self {
    MentsuPaiArgs {
      pai_num: 0,
      id: 0,
      flag: MentsuFlag::FLAG_NONE,
    }
  }
}

pub struct MentsuPaiBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MentsuPaiBuilder<'a, 'b> {
  #[inline]
  pub fn add_pai_num(&mut self, pai_num: u8) {
    self.fbb_.push_slot::<u8>(MentsuPai::VT_PAI_NUM, pai_num, 0);
  }
  #[inline]
  pub fn add_id(&mut self, id: u8) {
    self.fbb_.push_slot::<u8>(MentsuPai::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_flag(&mut self, flag: MentsuFlag) {
    self.fbb_.push_slot::<MentsuFlag>(MentsuPai::VT_FLAG, flag, MentsuFlag::FLAG_NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MentsuPaiBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MentsuPaiBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MentsuPai<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MentsuPai<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MentsuPai");
      ds.field("pai_num", &self.pai_num());
      ds.field("id", &self.id());
      ds.field("flag", &self.flag());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MentsuPaiT {
  pub pai_num: u8,
  pub id: u8,
  pub flag: MentsuFlag,
}
impl Default for MentsuPaiT {
  fn default() -> Self {
    Self {
      pai_num: 0,
      id: 0,
      flag: MentsuFlag::FLAG_NONE,
    }
  }
}
impl MentsuPaiT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MentsuPai<'b>> {
    let pai_num = self.pai_num;
    let id = self.id;
    let flag = self.flag;
    MentsuPai::create(_fbb, &MentsuPaiArgs{
      pai_num,
      id,
      flag,
    })
  }
}
pub enum MentsuOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Mentsu<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Mentsu<'a> {
  type Inner = Mentsu<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Mentsu<'a> {
  pub const VT_PAI_LIST: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Mentsu { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MentsuArgs<'args>
  ) -> flatbuffers::WIPOffset<Mentsu<'bldr>> {
    let mut builder = MentsuBuilder::new(_fbb);
    if let Some(x) = args.pai_list { builder.add_pai_list(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MentsuT {
    let pai_list = self.pai_list().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    MentsuT {
      pai_list,
    }
  }

  #[inline]
  pub fn pai_list(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MentsuPai<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MentsuPai>>>>(Mentsu::VT_PAI_LIST, None)}
  }
}

impl flatbuffers::Verifiable for Mentsu<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MentsuPai>>>>("pai_list", Self::VT_PAI_LIST, false)?
     .finish();
    Ok(())
  }
}
pub struct MentsuArgs<'a> {
    pub pai_list: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MentsuPai<'a>>>>>,
}
impl<'a> Default for MentsuArgs<'a> {
  #[inline]
  fn default() -> Self {
    MentsuArgs {
      pai_list: None,
    }
  }
}

pub struct MentsuBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MentsuBuilder<'a, 'b> {
  #[inline]
  pub fn add_pai_list(&mut self, pai_list: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MentsuPai<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Mentsu::VT_PAI_LIST, pai_list);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MentsuBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MentsuBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Mentsu<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Mentsu<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Mentsu");
      ds.field("pai_list", &self.pai_list());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MentsuT {
  pub pai_list: Option<Vec<MentsuPaiT>>,
}
impl Default for MentsuT {
  fn default() -> Self {
    Self {
      pai_list: None,
    }
  }
}
impl MentsuT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Mentsu<'b>> {
    let pai_list = self.pai_list.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Mentsu::create(_fbb, &MentsuArgs{
      pai_list,
    })
  }
}
pub enum PlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Player<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Player<'a> {
  type Inner = Player<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Player<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_MENTSU: flatbuffers::VOffsetT = 6;
  pub const VT_TEHAI: flatbuffers::VOffsetT = 8;
  pub const VT_KAWAHAI: flatbuffers::VOffsetT = 10;
  pub const VT_TSUMOHAI: flatbuffers::VOffsetT = 12;
  pub const VT_IS_RIICHI: flatbuffers::VOffsetT = 14;
  pub const VT_IS_IPPATSU: flatbuffers::VOffsetT = 16;
  pub const VT_SCORE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Player { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerArgs<'args>
  ) -> flatbuffers::WIPOffset<Player<'bldr>> {
    let mut builder = PlayerBuilder::new(_fbb);
    builder.add_score(args.score);
    if let Some(x) = args.tsumohai { builder.add_tsumohai(x); }
    if let Some(x) = args.kawahai { builder.add_kawahai(x); }
    if let Some(x) = args.tehai { builder.add_tehai(x); }
    if let Some(x) = args.mentsu { builder.add_mentsu(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_is_ippatsu(args.is_ippatsu);
    builder.add_is_riichi(args.is_riichi);
    builder.finish()
  }

  pub fn unpack(&self) -> PlayerT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let mentsu = self.mentsu().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let tehai = self.tehai().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let kawahai = self.kawahai().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let tsumohai = self.tsumohai().map(|x| {
      Box::new(x.unpack())
    });
    let is_riichi = self.is_riichi();
    let is_ippatsu = self.is_ippatsu();
    let score = self.score();
    PlayerT {
      name,
      mentsu,
      tehai,
      kawahai,
      tsumohai,
      is_riichi,
      is_ippatsu,
      score,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Player::VT_NAME, None)}
  }
  #[inline]
  pub fn mentsu(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Mentsu<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Mentsu>>>>(Player::VT_MENTSU, None)}
  }
  #[inline]
  pub fn tehai(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pai<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pai>>>>(Player::VT_TEHAI, None)}
  }
  #[inline]
  pub fn kawahai(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pai<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pai>>>>(Player::VT_KAWAHAI, None)}
  }
  #[inline]
  pub fn tsumohai(&self) -> Option<Pai<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Pai>>(Player::VT_TSUMOHAI, None)}
  }
  #[inline]
  pub fn is_riichi(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Player::VT_IS_RIICHI, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_ippatsu(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Player::VT_IS_IPPATSU, Some(false)).unwrap()}
  }
  #[inline]
  pub fn score(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Player::VT_SCORE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Player<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Mentsu>>>>("mentsu", Self::VT_MENTSU, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pai>>>>("tehai", Self::VT_TEHAI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pai>>>>("kawahai", Self::VT_KAWAHAI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Pai>>("tsumohai", Self::VT_TSUMOHAI, false)?
     .visit_field::<bool>("is_riichi", Self::VT_IS_RIICHI, false)?
     .visit_field::<bool>("is_ippatsu", Self::VT_IS_IPPATSU, false)?
     .visit_field::<i32>("score", Self::VT_SCORE, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mentsu: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Mentsu<'a>>>>>,
    pub tehai: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pai<'a>>>>>,
    pub kawahai: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pai<'a>>>>>,
    pub tsumohai: Option<flatbuffers::WIPOffset<Pai<'a>>>,
    pub is_riichi: bool,
    pub is_ippatsu: bool,
    pub score: i32,
}
impl<'a> Default for PlayerArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayerArgs {
      name: None,
      mentsu: None,
      tehai: None,
      kawahai: None,
      tsumohai: None,
      is_riichi: false,
      is_ippatsu: false,
      score: 0,
    }
  }
}

pub struct PlayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_NAME, name);
  }
  #[inline]
  pub fn add_mentsu(&mut self, mentsu: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Mentsu<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_MENTSU, mentsu);
  }
  #[inline]
  pub fn add_tehai(&mut self, tehai: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Pai<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_TEHAI, tehai);
  }
  #[inline]
  pub fn add_kawahai(&mut self, kawahai: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Pai<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_KAWAHAI, kawahai);
  }
  #[inline]
  pub fn add_tsumohai(&mut self, tsumohai: flatbuffers::WIPOffset<Pai<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Pai>>(Player::VT_TSUMOHAI, tsumohai);
  }
  #[inline]
  pub fn add_is_riichi(&mut self, is_riichi: bool) {
    self.fbb_.push_slot::<bool>(Player::VT_IS_RIICHI, is_riichi, false);
  }
  #[inline]
  pub fn add_is_ippatsu(&mut self, is_ippatsu: bool) {
    self.fbb_.push_slot::<bool>(Player::VT_IS_IPPATSU, is_ippatsu, false);
  }
  #[inline]
  pub fn add_score(&mut self, score: i32) {
    self.fbb_.push_slot::<i32>(Player::VT_SCORE, score, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Player<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Player<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Player");
      ds.field("name", &self.name());
      ds.field("mentsu", &self.mentsu());
      ds.field("tehai", &self.tehai());
      ds.field("kawahai", &self.kawahai());
      ds.field("tsumohai", &self.tsumohai());
      ds.field("is_riichi", &self.is_riichi());
      ds.field("is_ippatsu", &self.is_ippatsu());
      ds.field("score", &self.score());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerT {
  pub name: Option<String>,
  pub mentsu: Option<Vec<MentsuT>>,
  pub tehai: Option<Vec<PaiT>>,
  pub kawahai: Option<Vec<PaiT>>,
  pub tsumohai: Option<Box<PaiT>>,
  pub is_riichi: bool,
  pub is_ippatsu: bool,
  pub score: i32,
}
impl Default for PlayerT {
  fn default() -> Self {
    Self {
      name: None,
      mentsu: None,
      tehai: None,
      kawahai: None,
      tsumohai: None,
      is_riichi: false,
      is_ippatsu: false,
      score: 0,
    }
  }
}
impl PlayerT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Player<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mentsu = self.mentsu.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let tehai = self.tehai.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let kawahai = self.kawahai.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let tsumohai = self.tsumohai.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let is_riichi = self.is_riichi;
    let is_ippatsu = self.is_ippatsu;
    let score = self.score;
    Player::create(_fbb, &PlayerArgs{
      name,
      mentsu,
      tehai,
      kawahai,
      tsumohai,
      is_riichi,
      is_ippatsu,
      score,
    })
  }
}
}  // pub mod OpenMahjong

